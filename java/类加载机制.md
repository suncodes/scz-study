## 类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。



首先分析一个程序可能存在哪些东西：

static final 类变量

static 类变量

final 域变量

普通域变量



static final 方法

static 方法

final 方法

普通方法



static 域

非静态域



基本上就是这些了吧。

那在类加载中，这些东西处于哪些阶段，会发生哪些反应。这就需要关注的问题。



![1554191604991](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1554191604991.png)



==================

首先是加载阶段：

在加载阶段，虚拟机需要完成以下3件事情：
1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。



通俗来说就是 把Class文件，通过二进制流的形式 读到JVM中。

（也就是说，编译器已经把程序 编译好了。）

（类加载机制是在要使用的时候，才触发的；这里的使用，不是加载机制中的使用）



**加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。**



======================

验证阶段：

目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致上会完成下面4个阶段的检验动作：

文件格式验证：魔数，常量类型，utf8编码等。

元数据验证：语义分析，父类，是否继承，是否抽象，是否与父类字段冲突。

字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。

具体的参见《深入理解java虚拟机》



======================

准备阶段：

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

**需要注意：**

1.操作对象：类变量（static修饰的成员变量），不包括实例变量

2.方法区

3.static 初始化为0

4.static final 初始化为程序中指定的值。



=========================

解析阶段：

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

里面还是有很多道道的。



========================

初始化阶段：

类初始化阶段是类加载过程的最后一步，到了初始化阶段，**才真正开始执行类中定义的java程序代码**。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：**初始化阶段是执行类构造器<clinit>()方法的过程.**
<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

首先：

**在编译阶段就已经产生<clinit>()类构造器了。**

其次：

**在初始化的时候，<clinit>()方法被调用执行，且只被调用一次。**



1.＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。

2.关于接口的<clinit>()见下面ps。

3.<clinit>()方法只别调用一次。也就对于static只别初始化一次。



===================

至此，总结一下：

在加载过程，除了加载，验证阶段，操作的都是static变量。



static final 类变量 ----------在准备阶段就已经被初始化了，且调用不会引起类的初始化阶段（也就是不会引起类的加载）

static 类变量 ---------- 在准备阶段进行分配内存，初始化为0；在初始化阶段进行真正的初始化操作。调用此字段，会引起类的初始化。

final 域变量 ------------- 经历加载，验证阶段，不会经历准备与初始化阶段，

普通域变量 ------------- 经历加载，验证阶段，不会经历准备与初始化阶段，



static final 方法 ------------ 经历加载，验证阶段，不会经历准备与初始化阶段，

static 方法 ------------ 经历加载，验证阶段，不会经历准备与初始化阶段，

final 方法 ------------ 经历加载，验证阶段，不会经历准备与初始化阶段，

普通方法 ------------ 经历加载，验证阶段，不会经历准备与初始化阶段，



static 域 ------------ 加载，校验，在初始化阶段进行真正的初始化操作。不经过准备阶段。

非静态域  ------------ 经历加载，验证阶段，不会经历准备与初始化阶段，



准备阶段：只对类变量进行操作，

初始化阶段：对类变量以及静态域进行操作。



======================

什么时候发生类加载？

**（准确的说是什么时候发生初始化？，因为虚拟机只规定什么时候进行初始化，没有规定什么时候进行类加载。。）**

1.new 关键字实例化对象

2.读取或设置一个类的静态字段

3.调用一个类的静态方法

4.反射

5.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

6.main函数入口



除此之外，特别注意：

一些动作不会引起类加载。准确的说是不会引起初始化。

1.通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

（因为在初始化阶段之前，是不会执行java程序的，所以自然就打印不出相应的语句，也就是不能通过控制台来查看是否进行了初始化之前的操作；至于是否要触发子类的加载和验证，对于Sun HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作会导致子类的加载。）

例子：

```java
package org.fenixsoft.classloading;
/**
*被动使用类字段演示一：
*通过子类引用父类的静态字段，不会导致子类初始化
**/
public class SuperClass{
static{
System.out.println("SuperClass init！");
}
public static int value=123;
}
public class SubClass extends SuperClass{
static{
System.out.println("SubClass init！");
}
}
/**
*非主动使用类字段演示
**/
public class NotInitialization{
public static void main(String[]args) {
System.out.println(SubClass.value);
}
}
```

输出：SuperClass init！

123



2.创建数组不会触发初始化。

```java
package org.fenixsoft.classloading;
/**
*被动使用类字段演示二：
*通过数组定义来引用类，不会触发此类的初始化
**/
public class NotInitialization{
public static void main(String[]args) {
SuperClass[]sca=new SuperClass[10];
}
}

```

输出：没有任何输出



3.被final修饰、已在编译期把结果放入常量池的静态字段（static final）不会触发初始化。

```java
package org.fenixsoft.classloading;
/**
*被动使用类字段演示三：
*常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
**/
public class ConstClass{
static{
System.out.println("ConstClass init！");
}
public static final String HELLOWORLD="hello world";
}
/**
*非主动使用类字段演示
**/
public class NotInitialization{
public static void main(String[]args){
System.out.println(ConstClass.HELLOWORLD);
}
}
```

输出：没有任何输出。



这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。



另一个例子：


```java
package jvm.classload;

public class StaticTest
{
    public static void main(String[] args)
    {
        staticFunction();
    }

    static StaticTest st = new StaticTest();
    
    static
    {
        System.out.println("1");
    }
    
    {
        System.out.println("2");
    }
    
    StaticTest()
    {
        System.out.println("3");
        System.out.println("a="+a+",b="+b);
    }
    
    public static void staticFunction(){
        System.out.println("4");
    }
    
    int a=110;
    static int b =112;
}
```

结果：

2
3
a=110,b=0
1
4

类的生命周期是：加载->验证->准备->解析->初始化->使用->卸载，**只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值**，因此只针对这两个阶段进行分析；



仔细阅读：

类的准备阶段需要做是为类变量分配内存并设置默认值，因此类变量st为null、b为0；（需要注意的是如果类变量是final，编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量设置为指定的值，如果这里这么定义：static final int b=112,那么在准备阶段b的值就是112，而不再是0了。）
  类的初始化阶段需要做是执行类构造器（类构造器是编译器收集所有静态语句块和类变量的赋值语句按语句在源码中的顺序合并生成类构造器，对象的构造方法是<init>()，类的构造方法是<clinit>()，可以在堆栈信息中看到），因此先执行第一条静态变量的赋值语句即st = new StaticTest ()，此时会进行对象的初始化，对象的初始化是先初始化成员变量再执行构造方法，因此设置a为110->打印2->执行构造方法(打印3,此时a已经赋值为110，但是b只是设置了默认值0，并未完成赋值动作)，等对象的初始化完成后继续执行之前的类构造器的语句，接下来就不详细说了，按照语句在源码中的顺序执行即可。



这里面还牵涉到一个冷知识，就是在嵌套初始化时有一个特别的逻辑。特别是内嵌的这个变量恰好是个静态成员，而且是本类的实例。
  这会导致一个有趣的现象：“实例初始化竟然出现在静态初始化之前”。
  其实并没有提前，你要知道java记录初始化与否的时机。

根据上面的代码，有以下步骤：

1. 首先在执行此段代码时，首先由main方法的调用触发静态初始化。
2. 在初始化Test 类的静态部分时，遇到st这个成员。
3. 但凑巧这个变量引用的是本类的实例。
4. 那么问题来了，此时静态初始化过程还没完成就要初始化实例部分了。是这样么？
5. 从人的角度是的。但从java的角度，一旦开始初始化静态部分，无论是否完成，后续都不会再重新触发静态初始化流程了。
6. 因此在实例化st变量时，实际上是把实例初始化嵌入到了静态初始化流程中，并且在楼主的问题中，嵌入到了静态初始化的起始位置。这就导致了实例初始化完全至于静态初始化之前。这也是导致a有值b没值的原因。
7. 最后再考虑到文本顺序，结果就显而易见了。






ps：

关于接口的初始化问题：

1.接口不能定义static{}，只能定义static变量

2.接口会有<clinit>()类构造器

3.当子类进行类初始化时，父类不一定对进行类初始化

4.只有主动触发父类的初始化条件时，父类接口才进行初始化。



对象实例化过程：

1，JVM会去读取指定路径下的.class文件，并加载进内存，并会先加载父类（如果有直接父类的情况下）

（类加载阶段）

2，在堆内存中开辟空间，分配地址。
3，并在对象空间中，对对象中的属性进行默认初始化
4，调用对应的构造函数，进行初始化
5，在构造函数中，第一行会先调用父类中的构造函数进行初始化。
6，父类初始化完毕后，再对子类的属性，进行显示初始化。
7，指定构造函数的特定初始化
8，初始化完毕后，将堆内存中的地址值赋给引用变量。






https://blog.csdn.net/q1666035076/article/details/76066557 


https://blog.csdn.net/u013256816/article/details/50829596

https://blog.csdn.net/u013256816/article/details/50837863



最后：



这里面忽略了很多的知识点：

1.java class文件格式

2.类加载器

3.虚拟机字节码执行



哎，


