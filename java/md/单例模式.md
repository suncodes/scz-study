一张纸，可以遮去害羞，一段话，可以让人启发。



目标：对于单例模式，有好几种实现方法，需要弄清楚之间的区别，以及为什么不是线程安全的。



单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。



1，不应该使用`new`关键字创建对象

2，只能通过静态方法获取实例

3，获取的实例是同一个

（在springboot中@Resource也是获取实例的，不过不同的类获取的实例不是同一个）



单例的实现主要是通过以下两个步骤：

1. 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
2. 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。



注意线程安全问题



1，饿汉式（静态常量）

```java
public class Singleton {

private final static Singleton INSTANCE = new Singleton();

private Singleton(){}

public static Singleton getInstance(){
    return INSTANCE;
}

}

```

在类加载的时候就创建 静态实例

线程安全的，

但会消耗内存，如果不用的话，就白创建了。



------

2，饿汉式（静态代码块）

```java
public class Singleton {

    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

在类加载的时候就创建 静态实例

线程安全的，

但会消耗内存，如果不用的话，就白创建了。



------

3，懒汉式（线程不安全）

```java
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

单线程可以用，多线程不安全

两个线程同时创建实例的时候，会出现两个实例



------

4，懒汉式（线程安全，synchronized）

```java
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。



------

6，双重检查

```java
public class Singleton {

    private static volatile Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

注意：

1，需要加上`volatile` 关键字，不然会因为jvm指令从排序变得线程不安全

2，在jdk1.5之前，即使加上volatile关键字，也是线程不安全的，因为当时的volatile关键字内存语义不足以支持。

在jdk1.5之后，是可以使用的



------

7，静态内部类

```java
public class Singleton {

    private Singleton() {}

    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。

类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

优点：避免了线程不安全，延迟加载，效率高。



------

8，枚举方式

```java
public enum Singleton {
    INSTANCE;
    public void whateverMethod() {

    }
}
```



总结：

考虑的优先级：

1，枚举方式

2，静态内部类方式

3，双重检查方式

4，同步synchronized方式



------



这里面涉及一些知识点需要稍微总结一下。



1，有关双重检查volatile问题,

2，有关静态内部类加载时机

3，有关枚举类的使用



1，有关双重检查volatile问题,

volatile禁止重排序，指的是，在volatile关键字之前的语句，需要全部执行完毕。

如果不使用volatile来实现双重检查：

```java
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton(); // 1
                }
            }
        }
        return singleton;
    }
}

```



这里面主要问题在 //1 处的代码，

这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。
  　　1. 给 singleton 分配内存
    　　2. 调用 Singleton 的构造函数来初始化成员变量，形成实例
      　　3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）



在JVM的即时编译器中存在指令重排序的优化。
　　
也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。
　　
再稍微解释一下，就是说，由于有一个『instance已经不为null但是仍没有完成初始化』的中间状态，而这个时候，如果有其他线程刚好运行到第一层if (instance ==null)这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的instance拿去用了，就会产生问题。这里的关键在于线程T1对instance的写操作没有完成，线程T2就执行了读操作。



问题原因：

先执行 1 分配内存，之后因为重排序执行 3 对象指向分配的空间，这时候对象是非null的。

这时候有另一个线程，去读对象，会发现非空，就直接返回了，从而返回一个非null，但没有实例化的对象。



https://www.cnblogs.com/zhaoyan001/p/6365064.html

https://blog.csdn.net/weixin_37817685/article/details/80261549



2，静态内部类加载时机

在使用的时候加载，而不随着外部类加载而加载。









