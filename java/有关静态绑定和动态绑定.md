## 有关静态绑定和动态绑定



### 引题：

在书上看见过这样一句话：

“Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。”

那么方法重载为什么是静态绑定，因为重载的方法不一定是static的？



从 JVM 的角度来分析，方法调用的整个过程，自然也就明了了。



首先列出一个类中可能有哪些方法，之后来一点点分析。



static 方法

private 方法

final 方法

普通方法



还有一些其他的，比如：

static final 方法

private static/final 方法等一些组合的方法，

这些其实归为private / static 方法之内。



==========================

具体来说,Java字节码中与调用相关的指令共有五种:

1. invokestatic:用于调用静态方法
2. invokespecial:用于调用私有实例方法/构造器,以及使用super关键字调用父类的实例方法/构造器,和所有实现接口的默认方法
3. invokevirtual:用于调用非私有实例方法
4. invokeinterface:用于调用接口方法
5. invokedynamic:用于调用动态方法



所以说：



static ===========》invokestatic

private==========》invokespecial

final/普通========》invokevirtual





### 解析：

不同的指令，会有不同的操作。

首先对于static ，private方法，

编译器在编译期会形成符号引用。

在类加载过程的解析阶段，会把符号引用直接转为 该方法的直接引用。

有了直接引用，自然直接调用。



注意：符号引用是在编译期形成的，存放在方法区的常量池中。

符合引用转直接引用是在类加载过程的解析阶段。



### 分派：

而对于invokevirtual指令的方法，

编译器在编译期会形成符号引用。

在类加载过程的准备阶段，会初始化好方法表。

在类加载过程的解析阶段，会把符号引用转为 一个方法表的索引。

在运行的时候，会根据运行时的实际类型（注意实际类型和静态类型），查找方法表中的直接引用。



《优化》

invokevirtual指令的运行时解析过程大致分为以下几个步骤。

（这也是查找方法表的过程）

​       1）找到操作数栈顶的第一个元素(对象引用)所指向的对象的**实际类型**，记作C；

​       2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError。

​      3）否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证。

​      4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。



之所以能够这样查找：

方法表需要满足：

具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号

如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。

如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。、







其实这两个过程，就是解析和分派的过程。



对于静态绑定：

1.解析，属于静态绑定

2.分派：静态分派属于静态绑定

3.分派中的final方法，属于静态绑定

（static，final，private方法，属于静态绑定）



对于动态绑定：

1.分派：动态分派属于动态绑定过程。

（非私有的，非静态的，非final的，实例化方法的调用属于动态绑定）



好，说一说，重载和重写：



1.重载在编译期间，确定所使用的版本

2.重写在运行期间确定所调用的方法所属的类



注意：

* 一个类中可以有相同的名字，参数不同，这时候确定使用哪一个，是在编译期确定的。

怎样确定？

class B extends A{}

A a = new B();

这时候 A 为静态类型，B为实际类型。

在编译期，编译器使用的是，静态类型 来确定 方法的参数类型 ，选择哪一个合适。



* 不同的类可以有相同的名字，运行时确定。

这就是动态分派的过程。



其实这就可以注意到，重载是在编译期确定的；重写是在运行期确定的。



最后回答他们之间的区别，联系。

![1554372070146](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1554372070146.png)





重载是静态分派。

之所以说重载是静态绑定，是因为所需要的版本在编译期已经确定了。

（但这时候，不能说所使用的类已经确定，因为一个类有多个方法，也可能子类重写了这些方法

静态绑定只能确定，所使用函数的参数选择哪一个，不能确定，是使用子类还是父类，这还要交给动态分派。

）。



所以到了最后，

这里又个疑问，final方法在java虚拟机中标明是非虚方法，但是使用的是invokevirtual指令调用的； 那是否还和上面的invokevirtual指令的方法，调用过程一致？？？



答：final 在编译期 被绑定，也就是说在编译期，编译器已经确定了其符号引用，且符号引用所指向的地址在常量池，这样一来，在解析阶段，就可以直接转化为直接地址了。











https://www.cnblogs.com/mibloom/p/9613280.html

https://www.cnblogs.com/nyatom/p/9379013.html

http://www.cnblogs.com/chenyangyao/p/5305352.html































