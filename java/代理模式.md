## 代理模式



静态代理 和 动态代理

似乎两个小时的时间，整理不完，哼哼、



## 介绍

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**关键代码：**实现与被代理类组合。

**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

（参见菜鸟教程-[代理模式](https://m.runoob.com/design-pattern/proxy-pattern.html)）



#### 静态代理



代理模式理解:
有个场景，
有一家公司，你自己新入职，是个新员工。
而需要一个老员工带你。

这有点像代理模式。

公司的员工就是员工接口。
你自己就是员工的一个实现。
而老员工又是员工的实现。

你有很多东西不理解，
现在有个业务，需要你实现。

这时候你自己完不成呀，

所以需要老员工帮你，这相当于代理。
帮你把框架搭建出来。

之后你自己再去实现。

完成之后，客户不关心到底怎么完成的，
只知道这是这个公司的员工完成的。


这就是静态代理。

代理类，可以对被代理的类的方法进行加工。
这就是代理的意义。

首先有个接口，
代理类和被代理类都需要实现，因为对外需要返回一样的东西，不能体现差异。

其次，代理类需要知道要代理哪个，



说的很笼统，

写了一点代码，



员工接口：

```java
package designmode.proxy.staticproxy;

/**
 * 抽象角色：提供代理角色和真实角色对外提供的公共方法
 */
public interface Employee {

    /**
     * 员工都需要吃饭
     */
    void eat();

    /**
     * 员工都需要工作
     */
    void work();
}
```



真实的员工，相当于被代理类：

```java
package designmode.proxy.staticproxy;

/**
 * 姓王的员工
 */
public class WangEmployee implements Employee{
    public void eat() {
        System.out.println("wang 喜欢吃 水果");
    }

    public void work() {
        System.out.println("wang 正在做 登录项目");
    }
}
```



技术总监，相当于代理类：

```java
package designmode.proxy.staticproxy;

/**
 * 技术总监
 */
public class TechnicalChief implements Employee {

    private Employee employee;

    public TechnicalChief(Employee e) {
        employee = e;
    }
    public void eat() {
        System.out.println("技术总监 喜欢吃 米饭");
    }

    public void work() {
        System.out.println("技术总监需要和别人谈合作项目");
        // 找人去实现，
        employee.work();
        System.out.println("实现之后需要联调测试");
    }
}
```



客户：

```java
package designmode.proxy.staticproxy;

/**
 * 客户
 *
 * @author Administrator
 */
public class Client {
    public static void main(String[] args) {
        //对于客户，来说，不关心是谁实现的，只知道是这个公司的员工Employee
        Employee e = new TechnicalChief(new WangEmployee());
        e.work();
        e.eat();
    }
}
```

输出：

```
技术总监需要和别人谈合作项目
wang 正在做 登录项目
实现之后需要联调测试
技术总监 喜欢吃 米饭
```



====================================



动态代理：

说到动态，就会想到有很强的扩展性。

那么动态代理，能扩展什么，有哪些方便之处？



首先需要清楚 静态代理的代理类和那些因素相关。

1，实现的接口，

2，代理的哪个类



所以说动态代理，可以动态的加载某个接口，以及动态的加载别代理的类。

动态代理的优势主要在于：

动态的加载接口，这样，对于一类问题的解决有所帮助。

比如，我之前想要代理，日志。

这样，对于静态代理，不同的接口，需要实现不同的代理类。

而对于动态代理，只需要实现一个即可。



===================

可以先看代码，看了之后的解释之后，再回头看代码。



首先，依旧需要一个接口：

```java
package designmode.proxy.dynamicproxy;

/**
 * 抽象角色：提供代理角色和真实角色对外提供的公共方法
 */
public interface Employee {

    /**
     * 员工都需要吃饭
     */
    void eat();

    /**
     * 工作
     */
    void work();
}
```



其次需要一个真实的员工，即被代理的类：

```java
package designmode.proxy.dynamicproxy;

/**
 * 姓王的员工
 */
public class WangEmployee implements Employee {

    public void eat() {
        System.out.println("wang 喜欢吃 水果");
    }

    public void work() {
        System.out.println("wang 正在做 登录项目");
    }
}
```

之后，代理类，已经没了，取而代之的是，

```java
package designmode.proxy.dynamicproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

/**
 * 处理器
 */
public class ChiefHandler implements InvocationHandler {
    private Employee employee;//真实角色

    /**
     * 所有的流程控制都在invoke方法中
     * proxy：代理类
     * method：正在调用的方法
     * args：方法的参数
     */

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object object = null;
        System.out.println("技术总监需要和别人谈合作项目");

        object = method.invoke(employee, args);//激活调用的方法

        System.out.println("实现之后需要联调测试");
        return object;
    }

    //通过构造器来初始化真实角色
    public ChiefHandler(Employee employee) {
        super();
        this.employee = employee;
    }
}
```

其实这也是静态代理和动态代理的差别之处。

就是差别在代理类上。



```java
package designmode.proxy.dynamicproxy;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        //真实角色
        Employee employee = new WangEmployee();
        //处理器
        ChiefHandler chiefHandler = new ChiefHandler(employee);
        //代理类
        Employee proxy = (Employee) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), 
                new Class[]{Employee.class}, chiefHandler);
        proxy.work();
    }
}
```

结果：

```
技术总监需要和别人谈合作项目
wang 正在做 登录项目
实现之后需要联调测试
```



那么动态代理怎样实现的？

需要清楚整个流程：


```JAVA
public class Proxy implements Serializable {
    
    //被代理类构造函数的参数类型，即InvocationHandler
    private static final Class<?>[] constructorParams =
            { InvocationHandler.class };
    
    //代理对象的创建方法，通过Proxy.newProxyInstance(...)生成代理对象
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h) {
        
        ...省去一些方法，只显示核心代码
    
        final Class<?>[] intfs = interfaces.clone();
        //1，通过类加载器和接口创建代理类
        Class<?> cl = getProxyClass0(loader, intfs);
    
        //2，通过反射获取代理类中public类型的构造，且参数类型为InvocationHandler
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        //3，通过构造，创建代理类的实例对象，并返回
        return cons.newInstance(new Object[]{h});
     }
    
    //通过类加载器和接口，动态创建代理类。
    public static Class<?> getProxyClass0(ClassLoader loader, Class... interfaces)
    {...}

}
```

基本是三个步骤：

1，创建代理类

2，获取代理类的构造方法

3，返回代理类的实例



1，创建代理类

通过接口类型，会知道代理类继承的哪个接口，通过类加载器加载class文件。

这时候创建的代理类，和静态代理的模样差不多。



2，通过 InvocationHandler 参数获取构造函数

构造函数的参数是 InvocationHandler 类型。

有什么作用呢？

就是为了调用自己定义的invoke方法。

```java
 return (String)this.h.invoke((Object)this, m3, new Object[]{string});
```

首先 代理类$Proxy0（java中的名字），因为继承相应传过来的接口，所以需要实现相应的方法。

每个方法中都会返回类似上面的信息。



this 指的是代理类$Proxy0，需要调用InvocationHandler 中的invoke方法。

参数，this---》$Proxy0，m3---》相应的方法，new Object[]{string} ---》方法参数



而在invoke方法中，会调用相应的被代理类的方法

```JAVA
object = method.invoke(employee, args);//激活调用的方法
```



3，返回代理类的实例

没啥好说的



再根据这个main方法梳理一下执行流程：

```java
public static void main(String[] args) {
    //创建一个被代理的类
    Employee employee = new WangEmployee();
    //处理器，传入参数，这里可以把handler中构造函数的参数改为object，
    //不然，感觉使用动态代理没有啥意义，不具有通用性
    ChiefHandler chiefHandler = new ChiefHandler(employee);
    //代理类
    //首先创建一个代理类，$Proxy0，会继承new Class[]{Employee.class}中的接口，
    //在$Proxy0类中，需要重写继承接口的方法，在这些方法中会调用InvocationHandler中的invoke
    //chiefHandler用来指明调用哪个invoke，
    //在invoke中，会调用相同名字的方法，只是所属的对象变为了ChiefHandler构造方法中的类
    Employee proxy = (Employee) Proxy.newProxyInstance(
            ClassLoader.getSystemClassLoader(),
            new Class[]{Employee.class},
            chiefHandler);
    proxy.work();
}
```



具体就这些吧。



参考资料：https://www.jianshu.com/p/5478f170d9ee

以及尚学堂马士兵的视频教程



感觉是懂了，但是还是不是太熟练，有些生疏。

还需要再去想，思考，理解。再去看视频。





