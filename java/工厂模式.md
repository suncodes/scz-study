## 工厂模式

[简单工厂模式、工厂模式以及抽象工厂模式（具体）](https://blog.csdn.net/u012156116/article/details/80857255)

[工厂模式——看这一篇就够了](https://juejin.im/entry/58f5e080b123db2fa2b3c4c6)



工厂模式的场景：

屏蔽使用`new`关键字创建对象，用于实例化对象。



三种类型：

简单工厂模式，工厂方法，抽象工厂模式



####  简单工厂模式

就是通过类型或枚举来区分创建不同的对象实例。

接口：

```
public interface Shape {
    void draw();
}
```

实例：
圆形 

```
public class CircleShape implements Shape {

    public CircleShape() {
        System.out.println(  "CircleShape: created");
    }

    @Override
    public void draw() {
        System.out.println(  "draw: CircleShape");
    }

}
```

正方形

```
public class RectShape implements Shape {
    public RectShape() {
       System.out.println(  "RectShape: created");
    }

    @Override
    public void draw() {
       System.out.println(  "draw: RectShape");
    }

}
```

三角形

```
public class TriangleShape implements Shape {

    public TriangleShape() {
        System.out.println(  "TriangleShape: created");
    }

    @Override
    public void draw() {
        System.out.println(  "draw: TriangleShape");
    }

}
```

下面是工厂类的具体实现

```
 public class ShapeFactory {
          public static final String TAG = "ShapeFactory";
          public static Shape getShape(String type) {
              Shape shape = null;
              if (type.equalsIgnoreCase("circle")) {
                  shape = new CircleShape();
              } else if (type.equalsIgnoreCase("rect")) {
                  shape = new RectShape();
              } else if (type.equalsIgnoreCase("triangle")) {
                  shape = new TriangleShape();
              }
              return shape;
          }
   }
```

　　在这个工厂类中通过传入不同的type可以new不同的形状，返回结果为Shape 类型，这个就是简单工厂核心的地方了。
客户端使用

画圆形

```
    Shape shape= ShapeFactory.getShape("circle");
    shape.draw();
```

画正方形

```
    Shape shape= ShapeFactory.getShape("rect");
    shape.draw();
```

画三角形

```
    Shape shape= ShapeFactory.getShape("triangle");
    shape.draw();
```

　　只通过给ShapeFactory传入不同的参数就实现了各种形状的绘制。以上就是简单工厂方式，小伙伴们看明白了吗？

#### 工厂方法模式

对于一个接口，会有不同的实现，对于每个实现都有自己的工厂，用于创建自己的实例对象。

接口

```
public interface Reader {
    void read();
}
```

不同的实现：

Jpg图片加载器

```
public class JpgReader implements Reader {
    @Override
    public void read() {
        System.out.print("read jpg");
    }
}
```

Png图片加载器

```
public class PngReader implements Reader {
    @Override
    public void read() {
        System.out.print("read png");
    }
}
```

Gif图片加载器

```
public class GifReader implements Reader {
    @Override
    public void read() {
        System.out.print("read gif");
    }
}
```

抽象接口对应的抽象工厂

现在我们按照定义所说定义一个抽象的工厂接口ReaderFactory

```
public interface ReaderFactory {
    Reader getReader();
}
```

里面有一个getReader（）方法返回我们的Reader 类，接下来我们把上面定义好的每个图片加载器都提供一个工厂类，这些工厂类实现了ReaderFactory 。

不同的实现，都有自己的工厂。

Jpg加载器工厂

```
public class JpgReaderFactory implements ReaderFactory {
    @Override
    public Reader getReader() {
        return new JpgReader();
    }
}
```

Png加载器工厂

```
public class PngReaderFactory implements ReaderFactory {
    @Override
    public Reader getReader() {
        return new PngReader();
    }
}
```

Gif加载器工厂

```
public class GifReaderFactory implements ReaderFactory {
    @Override
    public Reader getReader() {
        return new GifReader();
    }
}
```

在每个工厂类中我们都通过复写的getReader（）方法返回各自的图片加载器对象。

客户端使用

读取Jpg

```
ReaderFactory factory=new JpgReaderFactory();
Reader  reader=factory.getReader();
reader.read();
```

读取Png

```
ReaderFactory factory=new PngReaderFactory();
Reader  reader=factory.getReader();
reader.read();
```

读取Gif

```
ReaderFactory factory=new GifReaderFactory();
Reader  reader=factory.getReader();
reader.read();
```

　　可以看到上面三段代码，分别读取了不同格式的图片，不同之处在于针对不同的图片格式声明了不同的工厂，进而创建了相应的图片加载器。

　　通过这个实例各位小伙伴是不是对工厂模式有了进一步的理解呢，和简单工厂对比一下，最根本的区别在于，简单工厂只有一个统一的工厂类，而工厂方法是针对每个要创建的对象都会提供一个工厂类，这些工厂类都实现了一个工厂基类（本例中的ReaderFactory ）。下面总结一下工厂方法的适用场景。

**适用场景：**

　　（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了床架过程。
　　（2）客户端可以通过子类来指定创建对应的对象。
以上场景使用于采用工厂方法模式。

#### 抽象工厂模式

　　这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。
　　抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。

**定义：**
　　提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。（ 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的对象）
　　
抽象工厂和工厂方法一样可以划分为4大部分：
AbstractFactory（抽象工厂）声明了一组用于创建对象的方法，注意是一组。
ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建对象的方法，生成一组具体对象。
AbstractProduct（抽象产品）：它为每种对象声明接口，在其中声明了对象所具有的业务方法。
ConcreteProduct（具体产品）：它定义具体工厂生产的具体对象。
下面还是先看一个具体实例。

**实例：**
　　现在需要做一款跨平台的游戏，需要兼容Android，Ios，Wp三个移动操作系统，该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController），下面通过抽闲工厂方式完成这款游戏的架构设计。

　　由题可知，游戏里边的各个平台的UIController和OperationController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。

抽象操作控制器

```
public interface OperationController {
    void control();
}
```

抽象界面控制器

```
public interface UIController {
    void display();
}
```

然后完成各个系统平台的具体操作控制器和界面控制器
Android

```
public class AndroidOperationController implements OperationController {
    @Override
    public void control() {
        System.out.println("AndroidOperationController");
    }
}

public class AndroidUIController implements UIController {
    @Override
    public void display() {
        System.out.println("AndroidInterfaceController");
    }
}
```

Ios

```
public class IosOperationController implements OperationController {
    @Override
    public void control() {
        System.out.println("IosOperationController");
    }
}

public class IosUIController implements UIController {
    @Override
    public void display() {
        System.out.println("IosInterfaceController");
    }
}
```

Wp

```
public class WpOperationController implements OperationController {
    @Override
    public void control() {
        System.out.println("WpOperationController");
    }
}
public class WpUIController implements UIController {
    @Override
    public void display() {
        System.out.println("WpInterfaceController");
    }
}
```

下面定义一个抽闲工厂，该工厂需要可以创建OperationController和UIController

```
public interface SystemFactory {
    public OperationController createOperationController();
    public UIController createInterfaceController();
}
```

在各平台具体的工厂类中完成操作控制器和界面控制器的创建过程

Android

```
public class AndroidFactory implements SystemFactory {
    @Override
    public OperationController createOperationController() {
        return new AndroidOperationController();
    }

    @Override
    public UIController createInterfaceController() {
        return new AndroidUIController();
    }
}
```

Ios

```
public class IosFactory implements SystemFactory {
    @Override
    public OperationController createOperationController() {
        return new IosOperationController();
    }

    @Override
    public UIController createInterfaceController() {
        return new IosUIController();
    }
}
```

Wp

```
public class WpFactory implements SystemFactory {
    @Override
    public OperationController createOperationController() {
        return new WpOperationController();
    }

    @Override
    public UIController createInterfaceController() {
        return new WpUIController();
    }
}
```

客户端调用：

```
    SystemFactory mFactory;
    UIController interfaceController;
    OperationController operationController;

    //Android
    mFactory=new AndroidFactory();
    //Ios
    mFactory=new IosFactory();
    //Wp
    mFactory=new WpFactory();

    interfaceController=mFactory.createInterfaceController();
    operationController=mFactory.createOperationController();
    interfaceController.display();
    operationController.control();
```

针对不同平台只通过创建不同的工厂对象就完成了操作和UI控制器的创建。小伙伴们可以对比一下，如果这个游戏使用工厂方法模式搭建需要创建多少个工厂类呢？下面总结一下抽象工厂的适用场景。

**适用场景：**
（1）和工厂方法一样客户端不需要知道它所创建的对象的类。
（2）需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。
（3）系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）



ps：

对于工厂方法和抽象工厂的不同之处，

对于抽象工厂，一个工厂创建一类对象

对于工厂方法，一个工厂创建一个对象



代理模式又忘了？？





补充：



而spring也使用工厂模式，什么意思？

工厂模式的核心是什么？ 不用关键字new 来实例化对象，而是把实例化对象的任务交给一个工厂类，或者说是封装起来，面向用户的只是一个方法，用于实例化，



Spring 则是把实例化的过程 自己封装起来，



具体的过程：



首先自己需要写一个接口，

UserService

```java
public interface UserService {
    public void sayHi();
}
```



之后有这个接口的实现：



```java
public class UserServiceImpl implements UserService {

    public void sayHi() {

        System.out.println("Hello Spring");

    }

}
```



spring用工厂模式的思想，通过配置文件，来加载，实例化对象。



先看看spring中是怎样使用的。



在 src/main/resources 目录下创建 spring-context.xml 配置文件：



```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"

       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xsi:schemaLocation="

       <http://www.springframework.org/schema/beans> <http://www.springframework.org/schema/beans/spring-beans.xsd>">



    <bean id="userService" class="com.funtl.hello.spring.service.impl.UserServiceImpl" />

</beans>
```



- <bean />：用于定义一个实例对象。一个实例对应一个 bean 元素。

- id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。

- class：指定该 Bean 所属的类，注意这里只能是类，不能是接口。



之后有个测试类，使用ClassPathXmlApplicationContext加载配置文件，然后使用getBean返回实例化对象。



```java
public class MyTest {



    public static void main(String[] args) {

        // 获取 Spring 容器

        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-context.xml");

        

        // 从 Spring 容器中获取对象

        UserService userService = (UserService) applicationContext.getBean("userService");

        userService.sayHi();

    }

}


```



首先我们需要清楚，实例化对象需要什么？

需要类加载器加载Class文件





1，Spring通过ClassPathXmlApplicationContext读取xml文件，之后解析xml，获取相应的key和value。

比如key：userService， value： com.funtl.hello.spring.service.impl.UserServiceImpl

之后把它放到Map容器里，这也是问什么说Spring通过容器实例化对象。

2，之后Spring使用ApplicationContext 的getBean方法，获取相应的key，之后获取value，通过类加载器加载相应的文件，之后通过反射获取相应的类，之后newInstance获取实例。

3，返回Object，强制转型即可。

这就是大致过程。



